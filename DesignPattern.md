## 设计模式

### 七大原则
1. 开闭原则 对扩展开放, 对修改关闭
2. 单一职责 一个类(接口, 方法)只干一件事
3. 依赖倒置 松耦合, 通过抽象,接口等方式
4. 接口隔离 不依赖不需要的接口
5. 迪米特   最少知道原则
6. 里氏替换 子类可以替换父类
7. 合成复用 尽量使用聚合而不是继承
   
### 简单工厂
### 工厂方法
    一个产品一个工厂
### 抽象工厂
    一个产品族
    
### 单例模式(懒汉式, 饿汉式)

### 原型模式(clone方法)

### 建造者模式
- 创建对象需要很多步骤, 但是顺序不定

### 代理模式
- 静态代理
- 动态代理(JDK, CGLIB)
- 保守代理对象, 增强代理对象...

### 门面模式 (又叫外观模式, 提供了一个统一的接口, 用来访问子系统中的一群接口)
- 其实也是一种特殊的静态代理模式 重点在于封装, 静态代理重点在于增强 以后讲到的委派模式(不属于GOF23)也是静态代理模式

### 装饰器模式
- 用于扩展一个类的功能或者给一个类添加职责
- 动态的给一个类添加功能, 这些功能可以再动态的撤销.
- 也可以认为是一种特殊的静态代理模式(类图很像)
- 

### 享元模式 (又称轻量级模式, 是对象池的一种实现)
* 
  
### 组合模式 (整体部分模式 树枝和叶子节点用同一个接口表示)
- 
### 适配器模式(又叫变压器模式)
- 将一个类的接口变成客户端期望的另外一个接口
- 
### 桥接模式
- 一个类存在两个或多个变化维度, 这两个维度都需要扩展
- 可以理解为多重继承的替代方案
- 
### 委派模式(不属于 GOF23)
- 负责任务的调度和分配, 将任务的分配和执行分离
- 比如老板给员工下达任务
- 
### 模板方法模式
- 定义一个算法的骨架, 允许子类为其中一个或者多个实现
- 可以加入钩子方法, 定制执行过程 (根据某个bool变量为真 or 假 )
- 
 ### 策略模式
- 将算法家族封装起来, 每个算法可以互相替换, 比如排序算法的 Comparator
- 
### 责任链模式
- 一条链中有很多节点, 每个节点处理完之后, 交给后面的节点
- 比如审批流程,

### 迭代器模式
- 提供按顺序访问集合中各个元素的方法, 并且不暴露集合的内部结构. 属于设计模式中的行为型模式
  
### 命令模式
- 将一个请求封装成一个对象, 从而使你可用不同的请求对客户进行参数化; 对请求排队或记录请求日志, 以及支持可撤销的操作. 属于设计模式中的行为型模式
- undo/redo实现

### 状态模式
- 允许对象在内部状态发生改变时改变它的行为, 对象看起来好像修改了它的类. 属于设计模式中的行为型模式
- 比如一个类有多个状态, 每个状态有不同的行为
- 订单状态, 电梯状态 等....
- spring提供了状态机可以帮我们管理状态
- 和责任链模式的区别 状态的改变是已经定义好了的, 用户不能改变, 责任链是在运行是用户可以设定的
- 和策略模式的区别 策略模式是用户自己定义的, 状态模式是框架定义好的

### 备忘录模式
- 保存类的状态 undo redo

### 中介者模式
- 使各个对象不需要显示地相互引用, 从而使其耦合松散, 而且可以独立地改变它们之间的交互. 属于设计模式中的行为型模式
- 比如聊天室, 聊天室需要通知所有用户, 这时候就需要一个中介者
- 
## 解释器模式
- 给定一个语言, 定义它的文法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的句子. 属于设计模式中的行为型模式
- 比如编译器, 解释器模式就是编译器
- 
## 观察者模式
- 定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新. 属于设计模式中的行为型模式
    
### 访问者模式
- 表示一个作用于某对象结构中的各元素的操作. 它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作.
- 比如一个文件系统, 文件夹和文件, 访问者模式就是对文件夹和文件进行操作, 而不需要改变文件夹和文件本身
- 
